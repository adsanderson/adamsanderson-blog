<!doctype html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>A quick look at testing behaviour</title><meta name="description" content="or: how to test what it does, not how it does it"><link rel="stylesheet" type="text/css" href="/static/css/style.css"><link rel="stylesheet" type="text/css" href="/static/css/prism-tomorrow.css"></head><body><div class="container max-w-4xl mt-6 px-6"><div class="pb-5 mb-5 border-b border-gray-100"><h1 class="font-bold text-5xl">A quick look at testing behaviour</h1><p class="text-center text-base leading-6 font-medium text-gray-500"><time>12 Aug 2015 by <a></a></time></p></div><article class="prose lg:prose-xl my-4 mx-auto"><p>One of my favourite concepts of testing is the idea of testing behaviour over the implementation. And for this I think it's easiest to explain by diving into an example.</p><h3>The background</h3><p>The pieces are pretty simple, we have a function createChecksum that takes an input and returns a checksum based on that input.</p><p>To get started the initial output will be the values from the input array that are joined together and separated by pipes, e.g [1, 2, 3] would return &quot;1|2|3&quot;</p><h3>When you're new to testing</h3><p>The initial temptation with unit testing is to be as explicit as possible. Inputting [1, 2, 3] should give us exactly &quot;1|2|3&quot;.</p><pre><code>var value = createChecksum([1, 2, 3]);
expect(value).to.be.equal(&quot;1|2|3&quot;);
</code></pre><p>Our function runs, our test passes, everyone sleeps well that night. Until we realise that we need to change our output.</p><h3>Should we care about the exact output?</h3><p>Here is where we start thinking in and testing behaviour, and not the implementation. The role of this checksum is not to give a specific output but to give us a value to be compared against (Is the checksum of array one the same as the checksum of array two?).</p><p>So that is where are tests should lead us: Do identical inputs give identical results; and do different inputs give different results.</p><p>Here is the first test to see if the checksums are consistent:</p><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">var</span> value <span class="token operator">=</span> <span class="token function">createChecksum</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">var</span> matchingValue <span class="token operator">=</span> <span class="token function">createChecksum</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token function">expect</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">.</span>be<span class="token punctuation">.</span><span class="token function">equal</span><span class="token punctuation">(</span>matchingValue<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>And the second test to see if different inputs give us different results:</p><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">var</span> value <span class="token operator">=</span> <span class="token function">createChecksum</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">var</span> differentValue <span class="token operator">=</span> <span class="token function">createChecksum</span><span class="token punctuation">(</span><span class="token punctuation">[</span>test<span class="token punctuation">,</span> test<span class="token punctuation">,</span> test<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token function">expect</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">.</span>not<span class="token punctuation">.</span>be<span class="token punctuation">.</span><span class="token function">equal</span><span class="token punctuation">(</span>differentValue<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3>Change the output, keep the behaviour</h3><p>So we have three tests Tests A, B and C. At the moment all of the tests are currently passing. But as the application develops we realise that are simple joined up checksum just isn't cutting it.</p><p>We need to use a hashing algorithm. So we updated are <code>createChecksum</code> function with the new hashing algorithm and run our tests again.</p><p>Test A now fails: expect (...hashed gibberish...) to equal &quot;1|2|3&quot;. However Tests B and C are still passing.</p><h3>This is the important bit</h3><p>The app is still working exactly as expected. We have a failing test but that should now be considered a bad test and be removed. The behaviour is consistent the code is up to date and free to be refactored again in the future. Because if the behaviour of the re-refactored code stays the same the tests will still pass.</p><h3>Final thoughts</h3><p>Just so it's been said, sometimes a test needs to be exact and explicit. That is when the behaviour is exact and specific. I have found creating these tests along side writing the code gives me a far greater insight into the behaviours of the project I'm working on; over simply diving straight into the code itself.</p></article></div><footer><nav><div><div><img src="https://www.gravatar.com/avatar/7b1630c267230ec687dd7133d3a2e2b3?s=80" class="logo__img" alt="Adam Sanderson"></div>A front-end developer based out of Hastings, UK</div><a href="/">Home<a href="https://github.com/adsanderson" title="Github"> github </a><a href="https://twitter.com/lazydayed" title="Twitter">twitter </a><a href="mailto:adam+site@adamsanderson.co.uk" rel="me">email</a></a></nav></footer><script src="/static/js/alpine.js"></script></body></html>