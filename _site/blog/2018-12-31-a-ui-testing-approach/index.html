<!doctype html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>A UI testing approach</title><meta name="description" content="or: How I wrote the same 3 tests over and over again"><link rel="stylesheet" type="text/css" href="/static/css/style.css"><link rel="stylesheet" type="text/css" href="/static/css/prism-tomorrow.css"></head><body><div class="container max-w-4xl mt-6 px-6"><div class="pb-5 mb-5 border-b border-gray-100"><h1 class="font-bold text-5xl">A UI testing approach</h1><p class="text-center text-base leading-6 font-medium text-gray-500"><time>31 Dec 2018 by <a></a></time></p></div><article class="prose lg:prose-xl my-4 mx-auto"><p>We are going to look at one way of structuring an app to help make your testing life easier.</p><h3>The architectural building block</h3><p>At a high level this is the fundamental rule that we are trying to following the architecture of our application:</p><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token function-variable function">updatePipeline</span> <span class="token operator">=</span> <span class="token parameter">evt</span> <span class="token operator">=></span> <span class="token function">updateUi</span><span class="token punctuation">(</span><span class="token function">updateState</span><span class="token punctuation">(</span>evt<span class="token punctuation">.</span>detail<span class="token punctuation">.</span>action<span class="token punctuation">)</span><span class="token punctuation">)</span><br>$el<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'a-custom-event'</span><span class="token punctuation">,</span> updatePipeline<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>or in a proposed pipeline style:</p><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token function-variable function">updatePipeline</span> <span class="token operator">=</span> <span class="token parameter">evt</span> <span class="token operator">=></span><br>  evt<span class="token punctuation">.</span>detail<span class="token punctuation">.</span>action<br>  <span class="token operator">|</span><span class="token operator">></span> updateState<br>  <span class="token operator">|</span><span class="token operator">></span> updateUi<br><br>$el<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'a-custom-event'</span><span class="token punctuation">,</span> updatePipeline<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Lets break down what is happening above: we start with an event, that calls the <code>updatePipeline</code> function. The <code>updatePipeline</code> function starts by taking some data from the event and updating the state.</p><p>This can follow a reducer pattern <code>state -&gt; action -&gt; state</code>. We have and initial state, we pass in our action and we get a new state at out the other side.</p><p>Once the state is updated, we then update our UI with the new state. This can be done by hand, and sometimes that is the best approach. In most circumstance this is where a state driven declarative UI library or framework should be used (As of writing this I would recommend Preact, lit-html, Svelte or HyperHTML as high quality <strong>light</strong> approaches).</p><h3>What this looks like</h3><p>At it's core there are three packages that makeup the application, with other packages and modules having important roles. A UI update module, that is responsible for taking the state and updating the UI based on the state. Generally there needs to be a DOM element to bind the UI too. The signature of this function should look something like <code>DOMElement -&gt; State -&gt; void</code> The function would not return anything but the side-effect would be an updated UI.</p><p>The next module would be the for the &quot;pipeline&quot; functions. This is where the core of the work happens. Generally I would say two dependencies are required. First the update UI function and the second a library for the remote calls. The advantage of having these 2 dependencies is the ability to mock them out and leaving you with more deterministic tests. A pipeline function could be responsible for multiple updates to the UI; imagine the fetchUser pipeline:</p><pre class="language-mermaid"><code class="language-mermaid"><span class="token keyword">graph</span> TD<br>I<span class="token text string">[Idle]</span> <span class="token arrow operator">--></span> A<br>A<span class="token text string">[Fetch]</span> <span class="token arrow operator">--></span> B<span class="token text string">[Success]</span><br>A <span class="token arrow operator">--></span> F<span class="token text string">[Failure]</span></code></pre><p>The single pipeline function can transition through each state change of the fetch request and update the UI as required.</p><p>The final core package is the event listener binder. This package is for managing the delegated event listeners. Binding a single event listener to a higher level DOM node and then calling the appropriate pipeline function when the event has been determined and cleaned. This package will have a dependency on the pipeline package.</p><p>The cycle is an <code>Event</code> triggers a <code>Pipeline</code> which updates the <code>UI</code>, which has events attached to it.</p><pre class="language-mermaid"><code class="language-mermaid"><span class="token keyword">graph</span> LR<br>A<span class="token text string">[UI]</span> <span class="token arrow operator">--></span> B<span class="token text string">[Events]</span><br>B <span class="token arrow operator">--></span> C<span class="token text string">[Pipelines]</span><br>C <span class="token arrow operator">--></span> A</code></pre><h3>What you need to test</h3><p>For tests like this to work you require some way of rendering DOM elements. My general go to is Jest with JSDOM, but tools for doing this are numerous.</p><h3>Testing the UI</h3><p>The purpose of the UI tests is to make sure that when the UI is updated with a state the correct DOM is produced. The tests for the UI package consist of rendering the UI and seeing if the DOM contains the expected elements. The setup would be:</p><p>graph TD State[Build state] --&gt; Render Render[Render UI] --&gt; Find Find[Find DOM node]</p><p>then the expectation would be:</p><pre class="language-js"><code class="language-js"><span class="token function">expect</span><span class="token punctuation">(</span>foundDOMNode<span class="token punctuation">)</span><span class="token punctuation">.</span>not<span class="token punctuation">.</span><span class="token function">toBeUndefined</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>If you make your UI driven entirely from the state, it makes this style of test very easy. With the UI frameworks that derive what changes to the UI that need to be made based on the state this helps create a very pure version of your UI.</p><h3>Testing the events</h3><p>The purpose of the event listeners is to call the correct function when an event is dispatched. This is what will be testing: The test is setup by:</p><pre class="language-mermaid"><code class="language-mermaid"><span class="token keyword">graph</span> TD<br><span class="token keyword">State</span><span class="token text string">[Build state]</span> <span class="token arrow operator">--></span> Render<br>Render<span class="token text string">[Render UI]</span> <span class="token arrow operator">--></span> Attach<br>Attach<span class="token text string">[Attach event listeners]</span> <span class="token arrow operator">--></span> Find<br>Find<span class="token text string">[Find DOM node]</span> <span class="token arrow operator">--></span> Trigger<br>Trigger<span class="token text string">[Trigger Event]</span></code></pre><p>Out expectation for this test is that the correct pipeline function will be triggered and we can use our mocked version of the pipeline package to test against that.</p><pre class="language-js"><code class="language-js"><span class="token function">expect</span><span class="token punctuation">(</span>mockPipeline<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toBeCalled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>We can expand this test to make sure the mock pipeline function is called with the correct values, that the events are being parsed properly. That bubbling is occurring as expected. With these examples the foundation of the test remains the same.</p><h3>Testing the pipelines</h3><p>The purpose of the pipeline is to trigger UI changes with the latest version of the state. We call the pipeline function with mocked UI and fetch functions, this allows us to log the state changes that are sent to the UI function.</p><pre class="language-mermaid"><code class="language-mermaid"><span class="token keyword">graph</span> TD<br><span class="token keyword">State</span><span class="token text string">[Build state]</span> <span class="token arrow operator">--></span> Call<br>Call<span class="token text string">[Call pipeline function]</span> <span class="token arrow operator">--></span> Log<br>Log<span class="token text string">[Log state passed to UI function]</span></code></pre><p>We then expect:</p><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> firstCallToUi <span class="token operator">=</span> mockUI<span class="token punctuation">.</span>mock<span class="token punctuation">.</span>called<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><br><span class="token function">expect</span><span class="token punctuation">(</span>firstCallToUi<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toBe</span><span class="token punctuation">(</span>expectedValue<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>This way we are testing the state changes, the potential paths through the pipeline and multiple state updates in the pipeline.</p><h3>Obvious testing</h3><p>Bending your architecture to testing is one way you can make testing easier, more obvious and more likely to happen. With the approach above I think you have a clean separation of roles that can compose together at a component level up to an application level.</p></article></div><footer><nav><div><div><img src="https://www.gravatar.com/avatar/7b1630c267230ec687dd7133d3a2e2b3?s=80" class="logo__img" alt="Adam Sanderson"></div>A front-end developer based out of Hastings, UK</div><a href="/">Home<a href="https://github.com/adsanderson" title="Github"> github </a><a href="https://twitter.com/lazydayed" title="Twitter">twitter </a><a href="mailto:adam+site@adamsanderson.co.uk" rel="me">email</a></a></nav></footer><script src="/static/js/alpine.js"></script></body></html>