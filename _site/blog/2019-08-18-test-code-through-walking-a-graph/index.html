<!doctype html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Test code through walking a graph</title><meta name="description" content="&#39;or: How I learned to walk a graph&#39;
"><link rel="stylesheet" type="text/css" href="/static/css/style.css"><link rel="stylesheet" type="text/css" href="/static/css/prism-tomorrow.css"></head><body><div class="container max-w-4xl mt-6 px-6"><div class="pb-5 mb-5 border-b border-gray-100"><h1 class="font-bold text-5xl">Test code through walking a graph</h1><p class="text-center text-base leading-6 font-medium text-gray-500"><time>26 Jul 2019 by <a></a></time></p></div><article class="prose lg:prose-xl my-4 mx-auto"><p>It is possible to model a component as a directed graph, showing the components states and the events to transition those states. Giving us a separate explanation of the behaviour of the component to the implementation of it.</p><p>This post is about how we can use that graph to test that an implementation of a component matches the desired behaviour, by walking the graph.</p><p>We will look at how to use <a href="https://xstate.js.org/docs/">XState</a> and state charts to derive a directed graph.</p><p>Look at the the graph for a component.</p><p>How to walk the graph using (Testing Library)[https://testing-library.com]</p><p>Finally explore some of the ideas and potential that's been covered.</p><h3>A state chart</h3><p>A UI (or more likely part of a UI) can be represented by a state chart. We can start with a simple a slightly modified version of the <a href="https://xstate.js.org/docs/guides/context.html#context">Glass state chart example</a> from the XState docs. The glass can be filled up in stages or emptied in one go. The glass can't be overfilled. It looks like this:</p><p><img src="https://res.cloudinary.com/lazydayed/image/upload/v1559403349/glass-component_rkwr4f.png" alt="Glass component UI"></p><p>Here is the state chart powering the component and it's visualisation:</p><pre class="language-js"><code class="language-js"> <span class="token punctuation">{</span><br>    id<span class="token operator">:</span> <span class="token string">"glass"</span><span class="token punctuation">,</span><br>    context<span class="token operator">:</span> <span class="token punctuation">{</span><br>      amount<span class="token operator">:</span> <span class="token number">0</span><br>    <span class="token punctuation">}</span><span class="token punctuation">,</span><br>    initial<span class="token operator">:</span> <span class="token string">"empty"</span><span class="token punctuation">,</span><br>    states<span class="token operator">:</span> <span class="token punctuation">{</span><br>      empty<span class="token operator">:</span> <span class="token punctuation">{</span><br>        on<span class="token operator">:</span> <span class="token punctuation">{</span><br>          <span class="token constant">FILL</span><span class="token operator">:</span> <span class="token punctuation">{</span><br>            target<span class="token operator">:</span> <span class="token string">"filling"</span><span class="token punctuation">,</span><br>            actions<span class="token operator">:</span> <span class="token string">"addWater"</span><br>          <span class="token punctuation">}</span><br>        <span class="token punctuation">}</span><br>      <span class="token punctuation">}</span><span class="token punctuation">,</span><br>      filling<span class="token operator">:</span> <span class="token punctuation">{</span><br>        on<span class="token operator">:</span> <span class="token punctuation">{</span><br>          <span class="token comment">// Transient transition</span><br>          <span class="token string">""</span><span class="token operator">:</span> <span class="token punctuation">{</span><br>            target<span class="token operator">:</span> <span class="token string">"full"</span><span class="token punctuation">,</span><br>            cond<span class="token operator">:</span> <span class="token string">"glassIsFull"</span><br>          <span class="token punctuation">}</span><span class="token punctuation">,</span><br>          <span class="token constant">FILL</span><span class="token operator">:</span> <span class="token punctuation">{</span><br>            target<span class="token operator">:</span> <span class="token string">"filling"</span><span class="token punctuation">,</span><br>            actions<span class="token operator">:</span> <span class="token string">"addWater"</span><br>          <span class="token punctuation">}</span><br>        <span class="token punctuation">}</span><br>      <span class="token punctuation">}</span><span class="token punctuation">,</span><br>      full<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><br>    <span class="token punctuation">}</span><span class="token punctuation">,</span><br>    on<span class="token operator">:</span> <span class="token punctuation">{</span><br>      <span class="token constant">EMPTY</span><span class="token operator">:</span> <span class="token punctuation">{</span><br>        target<span class="token operator">:</span> <span class="token string">"empty"</span><span class="token punctuation">,</span><br>        actions<span class="token operator">:</span> <span class="token string">"emptyWater"</span><br>      <span class="token punctuation">}</span><br>    <span class="token punctuation">}</span><br>  <span class="token punctuation">}</span></code></pre><p><img src="https://res.cloudinary.com/lazydayed/image/upload/v1559318478/glass-machine_eywwpc.png" alt="State chart used for Glass component"></p><p>We have three states (empty, filling, full), two events to transition between filling and emptying, guards to stop over filling and the ability to empty at any point.</p><h3>Graph</h3><p>It is possible to represent a state chart as a directed graph. Each state being a vertex and each transition being an edge. A very simple graph that can be generated from the Glass state chart would look like this:</p><p><img src="https://res.cloudinary.com/lazydayed/image/upload/v1559319236/glass-machine-graph_i44noe.png" alt="Graph representation of Glass state chart"></p><p>We can move:</p><ul><li>from <strong>empty</strong> to <strong>filling</strong></li><li>from <strong>filling</strong> to <strong>filling</strong></li><li>from <strong>filling</strong> to <strong>full</strong></li><li>from <strong>filling</strong> to <strong>empty</strong></li><li>from <strong>full</strong> to <strong>empty</strong></li></ul><p>We can't move <strong>empty</strong> to <strong>full</strong>, or from <strong>full</strong> to <strong>filling</strong></p><h3>Testing by walking the graph</h3><p>Walking the graph is the process of moving from vertex to vertex via an edge, or from state to state via events. We want to validate that the component being tested has correctly implemented the behaviour we have defined in our state chart.</p><p>The graph tells us what events are required. We can then look up a state and event; and interact with the component based on this lookup. This is where a library like <a href="https://testing-library.com">Testing library</a> comes in extremely useful for interactions.</p><p>An example of the <strong>empty</strong> to <strong>filling</strong> transition for the Glass component could look like this:</p><pre class="language-typescript"><code class="language-typescript"><span class="token keyword">const</span> transistion <span class="token operator">=</span> <span class="token punctuation">{</span><br>  empty<span class="token operator">:</span> <span class="token punctuation">{</span><br>    <span class="token function-variable function">FILL</span><span class="token operator">:</span> container <span class="token operator">=></span> <span class="token punctuation">{</span><br>      fireEvent<span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token function">getByText</span><span class="token punctuation">(</span>container<span class="token punctuation">,</span> <span class="token string">"Fill"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><p>Whenever we transition from <strong>empty</strong> to <strong>filling</strong> via a <strong>FILL</strong> event. The component should find the button that says &quot;Fill&quot; and click it.</p><p>To then go through multiple steps along the path we fill out the rest of the transitions and end up calling something like this:</p><pre class="language-typescript"><code class="language-typescript">transistion<span class="token punctuation">.</span>empty<span class="token punctuation">.</span><span class="token constant">FILL</span><span class="token punctuation">(</span>container<span class="token punctuation">)</span><span class="token punctuation">;</span><br>transistion<span class="token punctuation">.</span>filling<span class="token punctuation">.</span><span class="token constant">FILL</span><span class="token punctuation">(</span>container<span class="token punctuation">)</span><span class="token punctuation">;</span><br>transistion<span class="token punctuation">.</span>filling<span class="token punctuation">.</span><span class="token constant">FILL</span><span class="token punctuation">(</span>container<span class="token punctuation">)</span><span class="token punctuation">;</span><br>transistion<span class="token punctuation">.</span>filling<span class="token punctuation">.</span><span class="token constant">FILL</span><span class="token punctuation">(</span>container<span class="token punctuation">)</span><span class="token punctuation">;</span><br>transistion<span class="token punctuation">.</span>full<span class="token punctuation">.</span><span class="token constant">EMPTY</span><span class="token punctuation">(</span>container<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>The next step is then to validate that the state (and/or context) is correct. Again using Testing library we can check that the component has updated correctly. Rather than testing the internals of the state machine we are testing that the component is expressing the behaviour we expect.</p><pre class="language-typescript"><code class="language-typescript"><span class="token function">expect</span><span class="token punctuation">(</span><span class="token function">queryByTitle</span><span class="token punctuation">(</span>container<span class="token punctuation">,</span> <span class="token string">"The glass is about a quarter full"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toBeTruthy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3>Common paths</h3><p>Quite quickly paths become common. With the glass component getting to the point where the glass is full and then testing from there.</p><pre class="language-typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">fillTheGlass</span><span class="token punctuation">(</span>container<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  transistion<span class="token punctuation">.</span>empty<span class="token punctuation">.</span><span class="token constant">FILL</span><span class="token punctuation">(</span>container<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  transistion<span class="token punctuation">.</span>filling<span class="token punctuation">.</span><span class="token constant">FILL</span><span class="token punctuation">(</span>container<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  transistion<span class="token punctuation">.</span>filling<span class="token punctuation">.</span><span class="token constant">FILL</span><span class="token punctuation">(</span>container<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  transistion<span class="token punctuation">.</span>filling<span class="token punctuation">.</span><span class="token constant">FILL</span><span class="token punctuation">(</span>container<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>Having something like this in place makes refactoring easier as it reduces duplication, keeps consistency between tests as the same path is travelled and helps keep you working on the outside of the component and keeping you away from the implementation details.</p><p>I also find it is a good tool for finding and deleting redundant tests, a way of highlighting over testing. Where a path has been walked multiple times that could show potentially redundant tests, the important part is making sure that the each step is correctly validated.</p><h3>In action</h3><p>Below is an example code sandbox to see what I have written in action.</p><iframe src="https://codesandbox.io/embed/graphwalkingtesting-ny8l6?fontsize=14" title="graph-walking-testing" allow="geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media" style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe><h3>Observations</h3><p>One of the things I realised while working this way is that we are in fact creating a pseudo-state chart in the transitions look up. In fact although XState powers the component, a component does not require it to be powered by a state chart for it to be tested this way. The combination of a component and test both sharing the same underlying logic is very powerful. This does open the door to allowing existing code and components to be tested this way. By modelling the desired behaviour and then basing the tests on that.</p><p>These test feel a lot like the behaviour style tests from Cucumber and &quot;Given When Then&quot;. Where rather than mapping &quot;natural&quot; language to ways of interacting and validating a system under test; The statechart and visualisation is used to map the interactions to the behaviour.</p><p>Graph walking is at the heart of automated model-based testing. By using graph walking algorithms you can generate tests automatically based on the results.</p><p>Techniques like this help to move away from the how your application works to what it does. The goal is to make sure our application does what we want it to do.</p></article></div><footer><nav><div><div><img src="https://www.gravatar.com/avatar/7b1630c267230ec687dd7133d3a2e2b3?s=80" class="logo__img" alt="Adam Sanderson"></div>A front-end developer based out of Hastings, UK</div><a href="/">Home<a href="https://github.com/adsanderson" title="Github"> github </a><a href="https://twitter.com/lazydayed" title="Twitter">twitter </a><a href="mailto:adam+site@adamsanderson.co.uk" rel="me">email</a></a></nav></footer><script src="/static/js/alpine.js"></script></body></html>