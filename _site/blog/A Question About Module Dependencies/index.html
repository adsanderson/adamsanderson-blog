<!doctype html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>A Question About Module Dependencies</title><link rel="stylesheet" type="text/css" href="/static/css/style.css"><link rel="stylesheet" type="text/css" href="/static/css/prism-tomorrow.css"></head><body><div class="container max-w-4xl mt-6 px-6"><div class="pb-5 mb-5 border-b border-gray-100"><h1 class="font-bold text-5xl">A Question About Module Dependencies</h1><p class="text-center text-base leading-6 font-medium text-gray-500"><time>30 Aug 2014 by <a></a></time></p></div><article class="prose lg:prose-xl my-4 mx-auto"><p>After writing some custom Grunt tasks, and getting my feet wet with node, then following this up with some work using <a href="http://browserify.org/">browserify</a>. I had a feeling there would be a trend in front-end development for micro libraries (in the style of node) on the horizon.</p><p>I have yet to figure out if this will be a good thing for the front-end.</p><p>One of the strengths of node modules is how it deals with the dependencies for each module; and that is to keep each module and the modules it is dependant on in a separate package.</p><h2>That's a lot of utility libraries</h2><p>This can lead to duplication in a project. As two modules can both have a dependency to the same module but each package for those original two modules will have it's own version of the dependency included.</p><p><img src="/images/modules.png" alt="module example"></p><p>This can result in duplication in the final version of the product being produced.</p><p>As of writing (28th August 2014) there are 91 472 packages on <a href="https://www.npmjs.org/">npm</a>; and of the top ten most depended on packages underscore and lodash (two utility libraries that have a common API) are depended on by 11 647 packages (6937 and 4710 respectively). So just over 12% of the packages share this dependency and each package includes it's own version of underscore/lodash.</p><p><img src="/images/npm2014-08-28.png" alt="npmjs.org"></p><h2>Version was an important word</h2><p>One of the advantages of each package having it's own dependencies is the version of the depended on module does not matter. e.g. moduleA could require lodash 1.1.1; while the newer moduleB uses lodash 2.4.1.</p><h2>In the node world this way is working!</h2><p>Server side this works great. Everything is kept clean and separated. The advantages of this approach at the server (and local development) side greatly outweigh the costs of duplication.</p><h2>Will this work for the front-end</h2><p>In the front-end world of concatination and minification. The costs of duplication seem higher. More data being passed down the wire, more for the browser to process.</p><p>As with many things in the development world its striking that balance between the advantages a technology brings versus the costs.</p><p>So long term another technique could be used for smart reusable clean modules.</p><p>To use this node style technique in front-end development, while trying to minimise the costs of duplication, will require restraint from developers. Restraint from front-end devs to decide on a case by case basis of the costs of adding a new module.</p></article></div><footer><nav><div><div><img src="https://www.gravatar.com/avatar/7b1630c267230ec687dd7133d3a2e2b3?s=80" class="logo__img" alt="Adam Sanderson"></div>A front-end developer based out of Hastings, UK</div><a href="/">Home<a href="https://github.com/adsanderson" title="Github"> github </a><a href="https://twitter.com/lazydayed" title="Twitter">twitter </a><a href="mailto:adam+site@adamsanderson.co.uk" rel="me">email</a></a></nav></footer><script src="/static/js/alpine.js"></script></body></html>