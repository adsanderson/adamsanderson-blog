- main:
  - article:
    - heading "A UI testing approach" [level=1]
    - 'heading "or: How I wrote the same 3 tests over and over again" [level=2]'
    - paragraph: We are going to look at one way of structuring an app to help make your testing life easier.
    - heading "The architectural building block" [level=3]
    - paragraph: "At a high level this is the fundamental rule that we are trying to following the architecture of our application:"
    - code: const updatePipeline = (evt) => updateUi(updateState(evt.detail.action)); $el.addEventListener('a-custom-event', updatePipeline);
    - paragraph: "or in a proposed pipeline style:"
    - code: const updatePipeline = (evt) => evt.detail.action |> updateState |> updateUi; $el.addEventListener('a-custom-event', updatePipeline);
    - paragraph:
      - text: "Lets break down what is happening above: we start with an event, that calls the"
      - code: updatePipeline
      - text: function. The
      - code: updatePipeline
      - text: function starts by taking some data from the event and updating the state.
    - paragraph:
      - text: This can follow a reducer pattern
      - code: state -> action -> state
      - text: . We have and initial state, we pass in our action and we get a new state at out the other side.
    - paragraph:
      - text: Once the state is updated, we then update our UI with the new state. This can be done by hand, and sometimes that is the best approach. In most circumstance this is where a state driven declarative UI library or framework should be used (As of writing this I would recommend Preact, lit-html, Svelte or HyperHTML as high quality
      - strong: light
      - text: approaches).
    - heading "What this looks like" [level=3]
    - paragraph:
      - text: At it’s core there are three packages that makeup the application, with other packages and modules having important roles. A UI update module, that is responsible for taking the state and updating the UI based on the state. Generally there needs to be a DOM element to bind the UI too. The signature of this function should look something like
      - code: DOMElement -> State -> void
      - text: The function would not return anything but the side-effect would be an updated UI.
    - paragraph: "The next module would be the for the “pipeline” functions. This is where the core of the work happens. Generally I would say two dependencies are required. First the update UI function and the second a library for the remote calls. The advantage of having these 2 dependencies is the ability to mock them out and leaving you with more deterministic tests. A pipeline function could be responsible for multiple updates to the UI; imagine the fetchUser pipeline:"
    - code: graph TD I[Idle] --> A A[Fetch] --> B[Success] A --> F[Failure]
    - paragraph: The single pipeline function can transition through each state change of the fetch request and update the UI as required.
    - paragraph: The final core package is the event listener binder. This package is for managing the delegated event listeners. Binding a single event listener to a higher level DOM node and then calling the appropriate pipeline function when the event has been determined and cleaned. This package will have a dependency on the pipeline package.
    - paragraph:
      - text: The cycle is an
      - code: Event
      - text: triggers a
      - code: Pipeline
      - text: which updates the
      - code: UI
      - text: ", which has events attached to it."
    - code: graph LR A[UI] --> B[Events] B --> C[Pipelines] C --> A
    - heading "What you need to test" [level=3]
    - paragraph: For tests like this to work you require some way of rendering DOM elements. My general go to is Jest with JSDOM, but tools for doing this are numerous.
    - heading "Testing the UI" [level=3]
    - paragraph: "The purpose of the UI tests is to make sure that when the UI is updated with a state the correct DOM is produced. The tests for the UI package consist of rendering the UI and seeing if the DOM contains the expected elements. The setup would be:"
    - paragraph: graph TD State[Build state] –> Render Render[Render UI] –> Find Find[Find DOM node]
    - paragraph: "then the expectation would be:"
    - code: expect(foundDOMNode).not.toBeUndefined();
    - paragraph: If you make your UI driven entirely from the state, it makes this style of test very easy. With the UI frameworks that derive what changes to the UI that need to be made based on the state this helps create a very pure version of your UI.
    - heading "Testing the events" [level=3]
    - paragraph: "The purpose of the event listeners is to call the correct function when an event is dispatched. This is what will be testing: The test is setup by:"
    - code: graph TD State[Build state] --> Render Render[Render UI] --> Attach Attach[Attach event listeners] --> Find Find[Find DOM node] --> Trigger Trigger[Trigger Event]
    - paragraph: Out expectation for this test is that the correct pipeline function will be triggered and we can use our mocked version of the pipeline package to test against that.
    - code: expect(mockPipeline).toBeCalled();
    - paragraph: We can expand this test to make sure the mock pipeline function is called with the correct values, that the events are being parsed properly. That bubbling is occurring as expected. With these examples the foundation of the test remains the same.
    - heading "Testing the pipelines" [level=3]
    - paragraph: The purpose of the pipeline is to trigger UI changes with the latest version of the state. We call the pipeline function with mocked UI and fetch functions, this allows us to log the state changes that are sent to the UI function.
    - code: graph TD State[Build state] --> Call Call[Call pipeline function] --> Log Log[Log state passed to UI function]
    - paragraph: "We then expect:"
    - code: const firstCallToUi = mockUI.mock.called[0][0]; expect(firstCallToUi.value).toBe(expectedValue);
    - paragraph: This way we are testing the state changes, the potential paths through the pipeline and multiple state updates in the pipeline.
    - heading "Obvious testing" [level=3]
    - paragraph: Bending your architecture to testing is one way you can make testing easier, more obvious and more likely to happen. With the approach above I think you have a clean separation of roles that can compose together at a component level up to an application level.
- contentinfo:
  - navigation:
    - img "Adam Sanderson"
    - text: A front-end developer based out of Hastings, UK
    - link "Home"
    - link "github"
    - link "twitter"
    - link "email"